(function() {
  suite('Operators', function() {
    setup(function() {
      var letter, _i, _len, _ref, _results;
      this.emptyFunction = new CS.Function([], null);
      this.zero = new CS.Int(0);
      this.one = new CS.Int(1);
      _ref = ['a', 'b', 'c', 'd', 'e', 'f', 'F'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        letter = _ref[_i];
        _results.push(this[letter] = new CS.Identifier(letter));
      }
      return _results;
    });
    test('unary prefix operators', function() {
      eq('++0', generate(new CS.PreIncrementOp(this.zero)));
      eq('--0', generate(new CS.PreDecrementOp(this.zero)));
      eq('+0', generate(new CS.UnaryPlusOp(this.zero)));
      eq('+(+0)', generate(new CS.UnaryPlusOp(new CS.UnaryPlusOp(this.zero))));
      eq('-0', generate(new CS.UnaryNegateOp(this.zero)));
      eq('-(-0)', generate(new CS.UnaryNegateOp(new CS.UnaryNegateOp(this.zero))));
      eq('not 0', generate(new CS.LogicalNotOp(this.zero)));
      eq('!!0', generate(new CS.LogicalNotOp(new CS.LogicalNotOp(this.zero))));
      eq('!!!0', generate(new CS.LogicalNotOp(new CS.LogicalNotOp(new CS.LogicalNotOp(this.zero)))));
      eq('~0', generate(new CS.BitNotOp(this.zero)));
      eq('do 0', generate(new CS.DoOp(this.zero)));
      eq('typeof 0', generate(new CS.TypeofOp(this.zero)));
      return eq('new 0', generate(new CS.NewOp(this.zero, [])));
    });
    test('unary prefix operators and function literals', function() {
      eq('+->', generate(new CS.UnaryPlusOp(this.emptyFunction)));
      return eq('new ->', generate(new CS.NewOp(this.emptyFunction, [])));
    });
    test('unary prefix operators and function application', function() {
      eq('not f 0', generate(new CS.LogicalNotOp(new CS.FunctionApplication(this.f, [this.zero]))));
      eq('new F 0', generate(new CS.NewOp(this.F, [this.zero])));
      return eq('new (F 0) 1', generate(new CS.NewOp(new CS.FunctionApplication(this.F, [this.zero]), [this.one])));
    });
    test('unary prefix operators and application of function literals', function() {
      return eq('new (->) 0, 1', generate(new CS.NewOp(this.emptyFunction, [this.zero, this.one])));
    });
    test('unary postfix operators', function() {
      eq('0?', generate(new CS.UnaryExistsOp(this.zero)));
      eq('0++', generate(new CS.PostIncrementOp(this.zero)));
      return eq('0--', generate(new CS.PostDecrementOp(this.zero)));
    });
    test('unary postfix operators and function literals', function() {
      return eq('(->)?', generate(new CS.UnaryExistsOp(this.emptyFunction)));
    });
    test('unary postfix operators and function application', function() {
      eq('(f 0)?', generate(new CS.UnaryExistsOp(new CS.FunctionApplication(this.f, [this.zero]))));
      return eq('f()?', generate(new CS.UnaryExistsOp(new CS.FunctionApplication(this.f, []))));
    });
    test('unary prefix operators and unary postfix operators', function() {
      eq('+0++', generate(new CS.UnaryPlusOp(new CS.PostIncrementOp(this.zero))));
      eq('(+0)++', generate(new CS.PostIncrementOp(new CS.UnaryPlusOp(this.zero))));
      eq('new (F?)', generate(new CS.NewOp(new CS.UnaryExistsOp(this.F), [])));
      return eq('(new F)?', generate(new CS.UnaryExistsOp(new CS.NewOp(this.F, []))));
    });
    test('binary operators', function() {
      eq('0; 1', generate(new CS.SeqOp(this.zero, this.one)));
      eq('0 or 1', generate(new CS.LogicalOrOp(this.zero, this.one)));
      eq('0 and 1', generate(new CS.LogicalAndOp(this.zero, this.one)));
      eq('0 | 1', generate(new CS.BitOrOp(this.zero, this.one)));
      eq('0 ^ 1', generate(new CS.BitXorOp(this.zero, this.one)));
      eq('0 & 1', generate(new CS.BitAndOp(this.zero, this.one)));
      eq('0 is 1', generate(new CS.EQOp(this.zero, this.one)));
      eq('0 isnt 1', generate(new CS.NEQOp(this.zero, this.one)));
      eq('0 < 1', generate(new CS.LTOp(this.zero, this.one)));
      eq('0 <= 1', generate(new CS.LTEOp(this.zero, this.one)));
      eq('0 > 1', generate(new CS.GTOp(this.zero, this.one)));
      eq('0 >= 1', generate(new CS.GTEOp(this.zero, this.one)));
      eq('0 in 1', generate(new CS.InOp(this.zero, this.one)));
      eq('0 of 1', generate(new CS.OfOp(this.zero, this.one)));
      eq('0 instanceof 1', generate(new CS.InstanceofOp(this.zero, this.one)));
      eq('0 << 1', generate(new CS.LeftShiftOp(this.zero, this.one)));
      eq('0 >> 1', generate(new CS.SignedRightShiftOp(this.zero, this.one)));
      eq('0 >>> 1', generate(new CS.UnsignedRightShiftOp(this.zero, this.one)));
      eq('0 + 1', generate(new CS.PlusOp(this.zero, this.one)));
      eq('0 - 1', generate(new CS.SubtractOp(this.zero, this.one)));
      eq('0 * 1', generate(new CS.MultiplyOp(this.zero, this.one)));
      eq('0 / 1', generate(new CS.DivideOp(this.zero, this.one)));
      eq('0 % 1', generate(new CS.RemOp(this.zero, this.one)));
      return eq('a = 0', generate(new CS.AssignOp(this.a, this.zero)));
    });
    test('negated binary operators', function() {
      return eq('0 not in 1', generate(new CS.LogicalNotOp(new CS.InOp(this.zero, this.one))));
    });
    test('binary operators and function literals', function() {
      eq('(->) % 0', generate(new CS.RemOp(this.emptyFunction, this.zero)));
      eq('0 % ->', generate(new CS.RemOp(this.zero, this.emptyFunction)));
      eq('->; 0', generate(new CS.SeqOp(this.emptyFunction, this.zero)));
      return eq('0; ->', generate(new CS.SeqOp(this.zero, this.emptyFunction)));
    });
    test('binary operators and function application', function() {
      eq('f() % 0', generate(new CS.RemOp(new CS.FunctionApplication(this.f, []), this.zero)));
      eq('(f 0) % 1', generate(new CS.RemOp(new CS.FunctionApplication(this.f, [this.zero]), this.one)));
      eq('0 % f 1', generate(new CS.RemOp(this.zero, new CS.FunctionApplication(this.f, [this.one]))));
      return eq('f 0 % 1', generate(new CS.FunctionApplication(this.f, [new CS.RemOp(this.zero, this.one)])));
    });
    test('binary operators and unary operators on functions', function() {
      return eq('(do ->) % 0', generate(new CS.RemOp(new CS.DoOp(this.emptyFunction), this.zero)));
    });
    test('compound assignment operators', function() {
      eq('a += 0', generate(new CS.CompoundAssignOp(CS.PlusOp, this.a, this.zero)));
      eq('a or= 0', generate(new CS.CompoundAssignOp(CS.LogicalOrOp, this.a, this.zero)));
      eq('a &= 0', generate(new CS.CompoundAssignOp(CS.BitAndOp, this.a, this.zero)));
      return eq('a >>>= 0', generate(new CS.CompoundAssignOp(CS.UnsignedRightShiftOp, this.a, this.zero)));
    });
    test('static member access operators', function() {
      eq('a.b', generate(new CS.MemberAccessOp(this.a, 'b')));
      eq('a.b.c', generate(new CS.MemberAccessOp(new CS.MemberAccessOp(this.a, 'b'), 'c')));
      eq('f()?.a', generate(new CS.SoakedMemberAccessOp(new CS.FunctionApplication(this.f, []), 'a')));
      eq('(f 0)::a', generate(new CS.ProtoMemberAccessOp(new CS.FunctionApplication(this.f, [this.zero]), 'a')));
      eq('(->)?::a', generate(new CS.SoakedProtoMemberAccessOp(this.emptyFunction, 'a')));
      eq('(-> 0).a', generate(new CS.MemberAccessOp(new CS.Function([], new CS.Block([this.zero])), 'a')));
      eq('(new F).b', generate(new CS.MemberAccessOp(new CS.NewOp(this.F, []), 'b')));
      return eq('(new F 0).b', generate(new CS.MemberAccessOp(new CS.NewOp(this.F, [this.zero]), 'b')));
    });
    test('dynamic member access operators', function() {
      eq('a[0]', generate(new CS.DynamicMemberAccessOp(this.a, this.zero)));
      eq('a[0][1]', generate(new CS.DynamicMemberAccessOp(new CS.DynamicMemberAccessOp(this.a, this.zero), this.one)));
      eq('a?[\'b\']', generate(new CS.SoakedDynamicMemberAccessOp(this.a, new CS.String('b'))));
      eq('a::[c = 0]', generate(new CS.DynamicProtoMemberAccessOp(this.a, new CS.AssignOp(this.c, this.zero))));
      eq('a?::[0; 1]', generate(new CS.SoakedDynamicProtoMemberAccessOp(this.a, new CS.SeqOp(this.zero, this.one))));
      eq('f()[0]', generate(new CS.DynamicMemberAccessOp(new CS.FunctionApplication(this.f, []), this.zero)));
      eq('(f 0)[0]', generate(new CS.DynamicMemberAccessOp(new CS.FunctionApplication(this.f, [this.zero]), this.zero)));
      eq('(->)[0]', generate(new CS.DynamicMemberAccessOp(this.emptyFunction, this.zero)));
      eq('(-> 0)[0]', generate(new CS.DynamicMemberAccessOp(new CS.Function([], new CS.Block([this.zero])), this.zero)));
      eq('(new F)[0]', generate(new CS.DynamicMemberAccessOp(new CS.NewOp(this.F, []), this.zero)));
      return eq('(new F 0)[1]', generate(new CS.DynamicMemberAccessOp(new CS.NewOp(this.F, [this.zero]), this.one)));
    });
    return test('combinations of static/dynamic member access operators', function() {
      return eq('a.b[c]::d', generate(new CS.ProtoMemberAccessOp(new CS.DynamicMemberAccessOp(new CS.MemberAccessOp(this.a, 'b'), this.c), 'd')));
    });
  });

}).call(this);
